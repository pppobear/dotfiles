#!/usr/bin/env python3

import sys
import os
import subprocess
import json
import time
import fcntl
from pathlib import Path
import threading

CACHE_DIR = Path("/tmp/brightness_cache_dir")
CACHE_DIR.mkdir(exist_ok=True)
LOCK_FILE = "/tmp/brightness.lock"

class BrightnessControl:
    def __init__(self):
        self.cache_file = CACHE_DIR / "brightness_values.json"
        self.monitor_map_cache = CACHE_DIR / "monitor_ddcutil_map.json"
        self.load_brightness_cache()
        self.build_monitor_mapping()
        
    def load_brightness_cache(self):
        """Load cached brightness values"""
        try:
            if self.cache_file.exists():
                with open(self.cache_file) as f:
                    data = json.load(f)
                    if time.time() - data.get("timestamp", 0) < 5:
                        self.brightness_cache = data.get("values", {})
                    else:
                        self.brightness_cache = {}
            else:
                self.brightness_cache = {}
        except:
            self.brightness_cache = {}
    
    def build_monitor_mapping(self):
        """Build dynamic mapping between xrandr names and ddcutil displays"""
        # Check if cached mapping is still valid (cache for 60 seconds)
        try:
            if self.monitor_map_cache.exists():
                with open(self.monitor_map_cache) as f:
                    data = json.load(f)
                    if time.time() - data.get("timestamp", 0) < 60:
                        self.monitor_map = data.get("mapping", {})
                        return
        except:
            pass
        
        self.monitor_map = {}
        
        try:
            # Get ddcutil display info with DRM connectors
            ddcutil_output = subprocess.run(
                ["ddcutil", "detect"],
                capture_output=True, text=True, timeout=3
            ).stdout
            
            # Parse ddcutil output to get DRM connector for each display
            ddcutil_displays = {}
            current_display = None
            
            for line in ddcutil_output.split('\n'):
                if line.startswith('Display '):
                    current_display = line.split()[1]
                elif 'DRM_connector:' in line and current_display:
                    # Extract connector name (e.g., "card1-HDMI-A-1" -> "HDMI-A-1")
                    drm_connector = line.split()[-1]
                    if '-' in drm_connector:
                        connector_name = drm_connector.split('-', 1)[1]  # Remove "card1-" prefix
                        ddcutil_displays[connector_name] = current_display
            
            # Get xrandr monitor names
            xrandr_output = subprocess.run(
                ["xrandr"],
                capture_output=True, text=True, timeout=1
            ).stdout
            
            # Match xrandr names with ddcutil displays
            for line in xrandr_output.split('\n'):
                if ' connected ' in line:
                    monitor_name = line.split()[0]
                    
                    # Try to match with ddcutil connectors
                    # Direct match first
                    if monitor_name in ddcutil_displays:
                        self.monitor_map[monitor_name] = ddcutil_displays[monitor_name]
                    else:
                        # Try fuzzy matching (e.g., "DP-3" might match "DP-3" in ddcutil)
                        for drm_name, display_num in ddcutil_displays.items():
                            if monitor_name in drm_name or drm_name in monitor_name:
                                self.monitor_map[monitor_name] = display_num
                                break
            
            # Save mapping to cache
            with open(self.monitor_map_cache, 'w') as f:
                json.dump({
                    "timestamp": time.time(),
                    "mapping": self.monitor_map,
                    "ddcutil_displays": ddcutil_displays  # Save for debugging
                }, f, indent=2)
                
        except Exception as e:
            # Fallback to empty mapping if detection fails
            print(f"Warning: Monitor mapping failed: {e}", file=sys.stderr)
            self.monitor_map = {}
    
    def get_current_monitor_and_display(self):
        """Get current monitor name and corresponding ddcutil display number"""
        # Try niri method first (if running under niri)
        try:
            result = subprocess.run(
                ["niri", "msg", "focused-output"],
                capture_output=True, text=True, timeout=0.5
            )
            
            if result.returncode == 0:
                # Parse niri output: 'Output "Name" (DP-3)'
                output = result.stdout.strip()
                lines = output.split('\n')
                first_line = lines[0] if lines else ""
                
                if '(' in first_line and ')' in first_line:
                    # Extract connector name from parentheses in first line
                    connector = first_line.split('(')[-1].split(')')[0]
                    display_num = self.monitor_map.get(connector, "1")
                    return connector, display_num
        except:
            pass
        
        # Fallback to xdotool/xrandr method for X11/other WMs
        try:
            # Get mouse position
            result = subprocess.run(
                ["xdotool", "getmouselocation", "--shell"],
                capture_output=True, text=True, timeout=0.5
            )
            
            if result.returncode != 0:
                return None, "1"
            
            # Parse position
            pos = {}
            for line in result.stdout.strip().split('\n'):
                if '=' in line:
                    key, val = line.split('=')
                    pos[key] = int(val)
            
            # Get monitor layout
            result = subprocess.run(
                ["xrandr"], capture_output=True, text=True, timeout=0.5
            )
            
            for line in result.stdout.split('\n'):
                if ' connected ' in line:
                    parts = line.split()
                    if len(parts) >= 3:
                        monitor_name = parts[0]
                        # Parse geometry (e.g., "1920x1080+1920+0")
                        geo = parts[2] if parts[2] != 'primary' else parts[3]
                        if 'x' in geo and '+' in geo:
                            res, x_y = geo.split('+', 1)
                            width, height = res.split('x')
                            x_offset, y_offset = x_y.split('+')
                            
                            width = int(width)
                            height = int(height)
                            x_offset = int(x_offset)
                            y_offset = int(y_offset)
                            
                            # Check if mouse is in this monitor
                            if (x_offset <= pos.get('X', 0) < x_offset + width and
                                y_offset <= pos.get('Y', 0) < y_offset + height):
                                
                                # Get display number from mapping
                                display_num = self.monitor_map.get(monitor_name, "1")
                                return monitor_name, display_num
        except:
            pass
        
        # Return first available display as fallback
        if self.monitor_map:
            first_monitor = list(self.monitor_map.keys())[0]
            return first_monitor, self.monitor_map[first_monitor]
        
        return None, "1"
    
    def get_brightness_direct(self, display):
        """Get brightness using minimal ddcutil call"""
        cache_key = f"display_{display}"
        
        # Check cache first
        if cache_key in self.brightness_cache:
            cached_time, value = self.brightness_cache[cache_key]
            if time.time() - cached_time < 2:
                return value
        
        try:
            # Ultra-fast ddcutil call
            result = subprocess.run(
                ["ddcutil", "getvcp", "10", "--display", display, 
                 "--brief", "--sleep-multiplier", "0.05", "--less-sleep"],
                capture_output=True, text=True, timeout=0.8
            )
            
            if result.returncode == 0:
                # Parse output: "VCP 10 C 50 100"
                parts = result.stdout.strip().split()
                if len(parts) >= 4:
                    value = int(parts[3])
                    self.brightness_cache[cache_key] = (time.time(), value)
                    return value
        except:
            pass
        
        return 50  # Default
    
    def set_brightness_async(self, display, value):
        """Set brightness without waiting"""
        def _set():
            try:
                subprocess.run(
                    ["ddcutil", "setvcp", "10", str(value), 
                     "--display", display, "--noverify",
                     "--sleep-multiplier", "0.05", "--less-sleep"],
                    timeout=1.0, capture_output=True
                )
            except:
                pass
        
        # Update cache immediately
        cache_key = f"display_{display}"
        self.brightness_cache[cache_key] = (time.time(), value)
        self.save_brightness_cache()
        
        # Run in background thread
        thread = threading.Thread(target=_set, daemon=True)
        thread.start()
    
    def save_brightness_cache(self):
        """Save brightness values to cache"""
        try:
            with open(self.cache_file, 'w') as f:
                json.dump({
                    "timestamp": time.time(),
                    "values": self.brightness_cache
                }, f)
        except:
            pass
    
    def send_notification(self, monitor_name, display, value):
        """Send desktop notification"""
        try:
            # Show both monitor name and display number for clarity
            msg = f"{monitor_name} (Display {display}): {value}%"
            subprocess.run([
                "notify-send", "-a", "Backlight", "-u", "low",
                "-r", "9994", "-h", "string:x-canonical-private-synchronous:brightness",
                "-i", "brightness", msg, "-t", "600"
            ], timeout=0.5)
        except:
            pass
    
    def adjust(self, direction):
        """Main adjustment function"""
        monitor_name, display = self.get_current_monitor_and_display()
        current = self.get_brightness_direct(display)
        
        step = 5
        if direction == "up":
            new_value = min(100, current + step)
        else:
            new_value = max(10, current - step)
        
        # Set brightness asynchronously
        self.set_brightness_async(display, new_value)
        
        # Send notification immediately
        self.send_notification(monitor_name, display, new_value)
    
    def show_mapping(self):
        """Show current monitor mapping for debugging"""
        print("Current monitor mapping:")
        print(json.dumps(self.monitor_map, indent=2))
        
        if self.monitor_map_cache.exists():
            with open(self.monitor_map_cache) as f:
                data = json.load(f)
                print("\nDDCUtil displays detected:")
                print(json.dumps(data.get("ddcutil_displays", {}), indent=2))

def acquire_lock():
    """Prevent concurrent executions"""
    try:
        lock_fd = os.open(LOCK_FILE, os.O_CREAT | os.O_WRONLY)
        fcntl.flock(lock_fd, fcntl.LOCK_EX | fcntl.LOCK_NB)
        return lock_fd
    except:
        return None

def main():
    if len(sys.argv) < 2:
        print("Usage: brightness {up|down|show-mapping}")
        sys.exit(1)
    
    command = sys.argv[1]
    
    if command == "show-mapping":
        # Show mapping without lock
        controller = BrightnessControl()
        controller.show_mapping()
        sys.exit(0)
    
    if command not in ["up", "down"]:
        print("Usage: brightness {up|down|show-mapping}")
        sys.exit(1)
    
    # Try to acquire lock
    lock_fd = acquire_lock()
    if lock_fd is None:
        sys.exit(0)  # Another instance is running
    
    try:
        controller = BrightnessControl()
        controller.adjust(command)
    finally:
        os.close(lock_fd)
        try:
            os.unlink(LOCK_FILE)
        except:
            pass

if __name__ == "__main__":
    main()